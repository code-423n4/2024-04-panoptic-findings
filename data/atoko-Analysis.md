## Overview of Panoptic 

Panoptic is a cutting-edge  DeFi protocol that offers permissionless, perpetual options trading on any crypto asset, allowing users to trade options on any token, any strike, and any size without restrictions. This innovative platform aims to provide a seamless trading experience by enabling effortless options trading across a wide range of digital assets. By leveraging Panoptic, traders can access a versatile and efficient market, empowering them to explore diverse trading strategies and manage risk across various assets with ease.

***Some of the innovations include:***
`Permissionless Options`: Panoptic utilizes liquidity positions within Uniswap v3 pools to enable permissionless options trading. By shifting liquidity closer to or further from the spot price, traders can create short or long option positions, respectively. This allows for more flexible and dynamic options trading.

`Oracle-less Black-Scholes Pricing`: The protocol introduces a streaming premium model that initially starts with a zero premium and increases over time based on a path-dependent pricing formula. This model gradually converges to the Black-Scholes pricing model, eliminating the need for external oracles and providing a more reliable and transparent options pricing mechanism.

`Distinct User Roles`: Panoptic differentiates between buyers, sellers, and liquidity providers (LPs). Buyers and sellers interact directly with smart contracts to mint long and short options, while LPs provide liquidity without risking their capital. This separation of roles improves risk management and promotes liquidity in the market.

`Disentanglement of Trading Fees and LP Rewards`: Panoptic separates trading fees from LP rewards. LPs earn yields by lending liquidity to options buyers and sellers for a small fee, while the latter pay or receive premiums based on the fees generated by their Uniswap v3 options positions.

`Risk Management`: Options sellers bear most of the risk in the protocol, with the ability to sell undercollateralized options up to 5 times capital efficiency. Multi-leg options instruments with up to four puts or calls can also be deployed in a single transaction for more complex trading strategies.

Composability: Panoptic options can be tokenized as ERC-1155 tokens, which are tradable and composable with other DeFi and staking protocols. This enhances the protocol's interoperability and allows for more sophisticated financial products.

Panoptic addresses key challenges in on-chain options trading by offering a more efficient, flexible, and accessible protocol. It overcomes liquidity fragmentation and costly adjustments by utilizing Uniswap v3 pools for options trading. The protocol eliminates oracle dependency with an oracle-less Black-Scholes pricing model, broadening asset coverage. It enhances risk management through undercollateralized options and multi-leg options instruments, and it promotes composability by tokenizing options as ERC-1155 tokens that can integrate with other DeFi and staking protocols. Panoptic's innovations provide a comprehensive and versatile options trading experience in DeFi.

## System Overview

  * * ## CONTRACTS

## 1. SemiFungiblePositionManager.sol


The Semifungible Position Manager (SFPM) is a gas-efficient alternative to Uniswap's NonFungiblePositionManager that offers advanced management of complex, multi-leg Uniswap positions encoded in ERC-1155 token IDs. It enhances the users experience by allowing the minting of positions with only one type of token and supporting both traditional LP positions (adding liquidity to Uniswap) and "long" positions (burning Uniswap liquidity). This versatile tool serves as a crucial component of the Panoptic protocol, acting as the "engine" that empowers savvy Uniswap V3 LPs to manage their liquidity more efficiently and effectively. The SFPM smart contract manages LP positions using the ERC-1155 interface, wrapping up to four-legged Uniswap V3 positions in a single non-fungible token. This innovation provides a valuable upgrade for liquidity management and positions Panoptic as a robust solution in the decentralized finance ecosystem.

***Here is a breakdown of the key functions***:

***initializeAMMPool(token0, token1, fee)*** :

* `initializeAMMPool` function initializes a Uniswap v3 pool within the SemifungiblePositionManager (SFPM) contract. It takes in the contract addresses of two tokens `(token0 and token1)` and a `fee` level, then computes the address of the corresponding Uniswap v3 pool using the Uniswap factory.

If the pool has not been initialized, the function finds or creates a unique pool ID for the pool. It stores the pool's context (address and lock status) in a mapping and records the pool ID for the given Uniswap pool address, marking the pool as initialized. If the pool is already initialized or does not exist, the function reverts. Finally, it emits a PoolInitialized event indicating the Uniswap pool and its pool ID. This function should be called when a position is being created for the first time in the SFPM contract.

**Callback Handlers**

***uniswapV3MintCallback(amount0Owed, amount1Owed, data)*** :

* `uniswapV3MintCallback` function is called after liquidity is minted to a position. Its primary purpose is to pay the owed pool tokens for the minted liquidity from the payer (usually the caller).

it takes `amount0Owed` : The amount of token0 due to the pool for the minted liquidity. `amount1Owed` The amount of token1 due to the pool for the minted liquidity. and　`data` a byte array containing information such as the payer's address and the pool features required to validate the callback as parameters.

*Here is an overview of what the function does* :

`Decode Data `: The function begins by decoding the callback data to retrieve information such as the payer's address and pool features necessary to validate the callback.

`Validate Caller` : It validates the caller to ensure the function was called from the appropriate Automated Market Maker (AMM) pool.

`Transfer Tokens` : The function transfers the owed amounts of token0 and token1 from the payer to the caller (the AMM pool) for the minted liquidity.

The function ensures proper accounting for the minted liquidity by validating the source of the callback and making the necessary token transfers. This process maintains the integrity and accuracy of liquidity management in the SFPM contract.

***`uniswapV3SwapCallback(amount0Delta, amount1Delta, data)`***

*  `uniswapV3SwapCallback` function is called by a Uniswap pool after a swap operation is executed during an in-the-money (ITM) option minting or burning process. Its purpose is to pay the pool tokens owed for the swap from the payer, who is always the caller of the function.

it takes `amount0Delta` The amount of token0 that was either sent (negative value) or needs to be received (positive value) by the pool at the end of the swap. If positive, the function must send that amount of token0 to the pool.`amount1Delta` The amount of token1 that was either sent (negative value) or needs to be received (positive value) by the pool at the end of the swap. If positive, the function must send that amount of token1 to the pool. `data` a byte array containing the payer's address and the pool features required to validate the callback as parameters.

*Here is an overview of what the function does* :
`Decode Data`: The function decodes the callback data to retrieve the payer's address and the pool features for callback validation.
`Validate Caller`: It confirms that the function is being called from the correct Automated Market Maker (AMM) pool.
`Determine Token and Amount`: The function determines which token (token0 or token1) and the amount need to be sent based on the deltas.
`Transfer Tokens`: It transfers the owed tokens (token0 or token1) from the payer to the pool.
This function ensures that the necessary tokens are transferred from the payer to the pool in accordance with the outcomes of the swap, thereby facilitating accurate accounting and liquidity management in the pool.

## Mint/Burn functions

***mintTokenizedPosition(tokenId, positionSize, slippageTickLimitLow, slippageTickLimitHigh)*** :

* `mintTokenizedPosition` function enables the creation of a new position that contains up to 4 legs, encapsulated in an ERC-1155 token. It accepts a `tokenId` representing the position, a `positionSize` specifying the number of contracts to be minted, and slippage limits `(slippageTickLimitLow and slippageTickLimitHigh)` to manage price slippage during minting.

Upon execution, the function mints the specified position and emits an event indicating the minted position. It then validates the position and forwards the necessary liquidity chunks to the Automated Market Maker (AMM) for minting or burning.

*The function returns two key pieces of data* :

`collectedByLeg` : An array of LeftRight-encoded values representing the amount of token0 and token1 collected as fees for each leg of the position.
`totalSwapped` : A LeftRight-encoded value showing the total amount of token0 and token1 swapped if the position is being minted in-the-money (ITM).
This function plays a crucial role in managing positions within the SFPM contract and ensuring the creation of new positions adheres to specified parameters and limitations.

***burnTokenizedPosition(tokenId, positionSize, slippageTickLimitLow, slippageTickLimitHigh)*** :

* `burnTokenizedPosition` function allows users to burn a position that contains up to 4 legs, encapsulated in an ERC-1155 token. This action effectively removes the position and auto-collects any accumulated fees.

The function takes a `tokenId` representing the position, a `positionSize` specifying the number of contracts to be burnt, and slippage limits `(slippageTickLimitLow and slippageTickLimitHigh)` to manage price slippage during the burn process.

Upon execution, the function burns the specified position and emits an event indicating the burnt position. It then forwards the position data to the Automated Market Maker (AMM) for the necessary operations such as minting or burning the position, collecting amounts, and performing swaps if needed.

*The function returns* :

`collectedByLeg`: An array of LeftRight-encoded values representing the amount of token0 and token1 collected as fees for each leg of the position.
`totalSwapped` : A LeftRight-encoded value showing the total amount of token0 and token1 swapped during the burning process, if required.
This function plays a crucial role in managing positions within the SFPM contract and ensures the efficient and proper handling of positions according to the provided parameters and conditions.

## Transfer hook implementations

* *`safeTransferFrom(from, to, id, amount, data)`* : The function transfers a single token from one user to another while respecting token approvals.

* *`safeBatchTransferFrom(from, to ids, amounts, data)`* : The function transfers multiple tokens from one user to another while respecting token approvals.

* *`registerTokenTransfer(from,  to,  id,  amount)`* : The function updates user position data following a token transfer. Token transfers are only allowed if you transfer your entire liquidity of a given chunk and the recipient has none

## AMM Interaction & Position Update Helpers

* *`_validateAndForwardToAMM(tokenId, positionSize, tickLimitLow, tickLimitHigh)`* : it checks the proposed option position and size and forwards the minting and potential swapping tasks. Returns collectedByLeg An array of LeftRight encoded words containing the amount of token0 and token1 collected as fees for each leg and totalMoved the total amount of funds swapped in Uniswap as part of building potential ITM positions.

* *`swapInAMM(univ3pool, itmAmounts)`* : It performs a swap in the Uniswap AMM pool to adjust the token mix in an in-the-money (ITM) position. The function determines the net token imbalance and executes a swap to correct the token proportions, returning the total amount swapped. Returns the total amount of tokens swapped in the AMM, represented as a LeftRightSigned data structure.

* *`_createPositionInAMM(univ3pool, tokenId, positionSize, isBurn)`* : It creates the position in the AMM given in the tokenId. Returns the total amount of liquidity moved from the sender to Uniswap `(LeftRightSigned)`, an array of LeftRightUnsigned words containing the amount of token0 and token1 collected as fees for each leg, and the amount of tokens swapped due to legs being in-the-money `(LeftRightSigned)`.
   
        
* *`_createLegInAMM(univ3pool, tokenId, leg, liquidityChunk, isBurn)`* : It creates the position in the AMM for a specific leg in the tokenId. Returns the total amount of liquidity moved from the sender to Uniswap `(LeftRightSigned)`, the amount of tokens swapped due to legs being in-the-money `(LeftRightSigned)`, and LeftRightUnsigned encoded words containing the amount of token0 and token1 collected as fees for the specified leg.
       
* *`_updateStoredPremia(positionKey, currentLiquidity, collectedAmounts)`* : it's a private function that caches/stores the accumulated premia values for the specified postion.

* *`_getFeesBase(univ3pool, liquidity, liquidityChunk, roundUp)`* : It calculates the fee base for a specific liquidity position in a Uniswap pool and returns the result as LeftRightSigned values. The function optionally rounds the fee base up or down based on the roundUp parameter. Returns the fee base for a specific liquidity position in the Uniswap pool as a LeftRightSigned type, representing fees in terms of token0 and token1.

* *`_mintLiquidity(liquidityChunk, univ3pool)`* : It mints a chunk of liquidity (`liquidityChunk`) in the Uniswap v3 pool; Returns the amount moved.

* *`_burnLiquidity(liquidityChunk, univ3pool)`* : It Burns a chunk of liquidity (`liquidityChunk`) in the Uniswap v3 pool and send to msg.sender; Returns the amount moved.
        
* *`_collectAndWritePositionData(liquidityChunk, univ3pool, currentLiquidity, positionKey, movedInLeg, isLong)`* : It collects amounts between msg.sender and Uniswap and also to update the Uniswap fees collected to date from the AMM. Returns the incoming amount collected with potentially whatever is collected in this function added to it.

* *`_getPremiaDeltas(currentLiquidity, collectedAmounts)`* : It updates the Owed and Gross account liquidities. Returns two values: `deltaPremiumOwed` and `deltaPremiumGross`, which are both LeftRightUnsigned types representing the extra premium to be added to the owed and gross accumulators for token0 (right) and token1 (left).
       
## Properties

* *`getAccountLiquidity(univ3pool, owner, tokenType, tickLower, tickUpper)`* : It retrieves the liquidity associated with a position in a Uniswap v3 pool. Returns `LeftRightUnsigned` representing net liquidity `(rightSlot)` and removed liquidity `(leftSlot)` for a specified position based on owner, token type, and tick range.
       
* *`getAccountPremium(univ3pool, owner, tokenType, tickLower, tickUpper, atTick, isLong`* : It retrieves the premium associated with a given position in a Uniswap v3 pool for a specified owner, token type, and tick range. It calculates the premium by considering the account's net and removed liquidity, fee growth, and accumulated fees up to the provided tick. Returns the premium amounts for token0 and token1, either from the "Owed" or "Gross" accumulators based on whether the position is long or short.

* *`getAccountFeesBase(univ3pool, owner, tokenType, tickLower, tickUpper)`* : Returns the fees base for a given position in a Uniswap v3 pool, providing fees base for token0 and token1.

* *`getUniswapV3PoolFromId(poolId)`* :  Returns the Uniswap v3 pool instance corresponding to a given pool ID.

* *`getPoolId(univ3pool)`* : Returns the pool ID corresponding to a given Uniswap v3 pool address.
        
       
## 2. PanopticPool.sol


The PanopticPool contract serves as the primary interface for interacting with the Panoptic protocol, functioning as the main coordinator for the protocol's core functionality. It can be considered the "conductor" of the Panoptic ecosystem, orchestrating a variety of operations related to options trading and liquidity provision. The contract's key responsibilities include:

* *Position Management*: The Panoptic Pool oversees the minting and burning of option positions within Uniswap pools. It facilitates the creation and destruction of option positions according to users' requirements, ensuring seamless integration with the Uniswap liquidity pools.

* *Liquidation and Force Exercise* : The contract handles the liquidation of distressed accounts and the force exercise of positions that are in a state of distress. These actions are critical to maintaining the integrity and stability of the protocol.

* *Balance Tracking and Premium Accumulation* : The Panoptic Pool maintains a record of user balances and accumulates premiums on their positions. This tracking allows users to monitor their positions and understand their potential liabilities and earnings.

* *Data Coordination with CollateralTracker* : The contract interfaces with the CollateralTracker to provide necessary data for settling position changes and managing collateral efficiently. This collaboration ensures that position changes are accurately reflected in the broader system.

By orchestrating interactions with the Uniswap pool and coordinating various aspects of options trading, the Panoptic Pool is essential for the smooth functioning and robustness of the Panoptic protocol. It plays a central role in maintaining the protocol's efficiency and providing a reliable trading environment for its users.
        

               
***Here is a breakdown of the key functions***:

* *`startPool(_univ3pool, token0, token1, collateralTracker0, collateralTracker1)`* : The startPool function initializes a Panoptic Pool on top of an existing Uniswap v3 pair. It sets up the necessary interfaces and stores references to the Uniswap pool, collateral trackers for both tokens, and approves token allowances for interactions with other components. This function is essential for preparing the Panoptic Pool for further transactions and ensuring proper data and collateral management.

***Query Helpers***

* *`assertPriceWithinBounds(sqrtLowerBound, sqrtUpperBound)`* : Reverts if current Uniswap price is not within the provided bounds.

* *`optionPositionBalance(user, tokenId)`* : Returns the total number of contracts owned by user for a specified position. Returns the balance of contracts owned by a user for a specified token ID, along with the utilization of token0 and token1 in the Panoptic pool at the time of minting.

* *`calculateAccumulatedFeesBatch(user, includePendingPremium, positionIdList)`* : Computes the total amount of premium accumulated for a list of positions. Returns  the total accumulated premium for `token0` and `token1` for a list of positions owned by the specified user. Additionally, it provides a list of balances and pool utilization for each position in the format `[[tokenId0, balances0], [tokenId1, balances1], ...]`
       
* *`calculatePortfolioValue(user, atTick, positionIdList)`* : Computes the total value of the portfolio defined by the positionIdList at the given tick. Returns the total value of the user's portfolio defined by a list of positions at a specified tick. It provides the portfolio value in terms of `token0` and `token1`, where negative values indicate a loss compared to the starting value.
        
* *`_calculateAccumulatedPremia(user, positionIdList, computeAllPremia, includePendingPremium, atTick)`* : Calculates the accumulated premia owed from the option buyer to the option seller. Returns the computed premia of a user's positions and a list of balances and pool utilization for each position. The premia include accumulated premia for token0 in the right slot and token1 in the left slot, while the balances list contains balances and pool utilization for each position specified in the input list.

* *`_getSlippageLimits(tickLimitLow, tickLimitHigh)`* : it disables slippage checks if tickLimitLow == tickLimitHigh and reverses ticks if given in correct order to enable ITM swaps. Returns the adjusted values for the lower and upper tick limits.
        
             
***Onboard Median TWAP***

* *`pokeMedian()`* : It Updates the internal median with the last Uniswap observation if the MEDIAN_PERIOD has elapsed.

***Mint/Burn Interface***

* *`mintOptions(positionIdList, positionSize, effectiveLiquidityLimitX32, tickLimitLow, tickLimitHigh)`* : Validates the current options of the user, and mints a new position.

* *`burnOptions(tokenId, newPositionIdList, tickLimitLow, tickLimitHigh)`* : It Burns the entire balance of tokenId of the caller(msg.sender). should revert if user does not have enough collateral to exercise.

* *`burnOptions(positionIdList, newPositionIdList, tickLimitLow, tickLimitHigh`* : It Burns the entire balance of all tokenIds provided in positionIdList of the caller(msg.sender). should revert if use does not have enough collateral to exercise.
        
        
***Position Minting Logic***

* *`_mintOptions(positionIdList, positionSize, effectiveLiquidityLimitX32, tickLimitLow, tickLimitHigh)`* : Validates the current options of the user, and mints a new position.

* *`_mintInSFPMAndUpdateCollateral(tokenId, positionSize, tickLimitLow, tickLimitHigh)`* : It checks the users collateral status. Returns returns a packed value of the pool utilization at the time of minting, with the right 64 bits representing token0 utilization and the left 64 bits representing token1 utilization.
        
* *`_payCommissionAndWriteData(tokenId, positionSize, totalSwapped)`* : It calculates and pays the commission fees for creating the options and update internal state. Returns the packed pool utilization at the time of minting. The returned value contains the right 64 bits for `token0` utilization and the left 64 bits for `token1` utilization.

* *`_addUserOption(tokenId, effectiveLiquidityLimitX32)`* : It stores user option data and track fees collected for the options.
             

***Position Burning Logic***

* *`_burnAllOptionsFrom(owner, tickLimitLow, tickLimitHigh, commitLongSettled, positionIdList)`* : Helper to burn option during a liquidation from an account _owner. Returns the net amounts paid `(token0 and token1)` and a list of accumulated premium data for each leg of the burned positions.
        
* *`_burnOptions(commitLongSettled, tokenId, owner, tickLimitLow, tickLimitHigh)`* : A helper to burn an option position held by '_owner'. Returns the amount of tokens paid when closing the option `(paidAmounts)` and the accumulated premium owed to the user for each leg of the position `(premiaByLeg)`.
       
* *`_updatePositionDataBurn(owner,  tokenId)`* : Updates the internal tracking of the owner's position data upon burning a position.

* *`_validateSolvency(user, positionIdList, buffer)`* : It Validates the solvency of user at the fast oracle tick. Returns a medianData value if enough time has passed since the last observation, providing an updated value for the s_miniMedian with a new observation.
      
***Liquidations & Forced Exercises***

* *`liquidate(positionIdListLiquidator, liquidatee, delegations)`* : This function will liquidate a distressed account and  burn all positions and  issue a bonus to the liquidator. It reverts if liquidated account is solvent at the TWAP tick or if TWAP tick is too far away from the current tick.
       
* *`forceExercise(account, touchedId, positionIdListExercisee, positionIdListExercisor)`* : It will force the exercise of a single position. Exercisor will have to pay a fee to the force exercisee.

***Solvency Checks***

* *`_checkSolvencyAtTick(account, positionIdList, currentTick, atTick, buffer)`* : It checks whether an account is solvent at a given `atTick` with a collateral requirement. Returns a boolean value indicating whether an account is solvent at a given tick (atTick) with a specific collateral requirement (buffer), considering the account's positions, current tick of the Uniswap pool, and accumulated premiums.
        
* *`_getSolvencyBalances(tokenData0, tokenData1, sqrtPriceX96)`* : It gets the parameters related to the solvency state of the account associated with the incoming tokenData.
       
***Position Hash Generation & Validation***

* *`_validatePositionList(account, positionIdList, offset)`* : It makes sure that the positions in the incoming user's list match the existing active option positions.

* *`_updatePositionsHash(account, tokenId, addFlag)`* : Updates the hash for all positions owned by an account it acts as a fingerprint of lists on all incoming options with a single hash.

***Queries***

* *`univ3pool()`* : Gets the address of the AMM pool connected to this Panoptic pool.

* *`collateralToken0()`* : Gets the collateral token corresponding to `token0` of the AMM pool.

* *`collateralToken1()`* : Gets the collateral token corresponding to `token1` of the AMM pool.

* *`numberOfPositions(user)`* : gets the number of positions for an account.

* *`getUniV3TWAP()`* : Compute the TWAP price from the last time.


***Premia & Premia Spread Calculations***

* *`_checkLiquiditySpread(tokenId, leg, tickLower, tickUpper, effectiveLiquidityLimitX32)`* : Ensures the effective liquidity in a given chunk is above a certain threshold.

* *`_getPremia(tokenId, positionSize, owner, computeAllPremia, atTick)`* : It computes the premia collected for a single option position 'tokenId'. Returns the premiums for each leg of the position and their respective premium accumulators.


***Available Premium Logic***

* *`settleLongPremium(positionIdList, owner, legIndex)`* : This settles all unpaid premiums for long legs of a given option position `(tokenId)` on behalf of an owner. It verifies the solvency of the owner and calculates accumulated premiums, updating the owner's realized premiums and deducting the paid premium from the owner's balance. The function ensures the owner remains solvent after the settlement and emits an event for the settled premium.
        
* *`_updateSettlementPostMint(tokenId, collectedByLeg, positionSize)`* : Adds collected tokens to settled accumulator and adjusts grossPremiumLast for any liquidity added

* *`_getAvailablePremium(totalLiquidity, settledTokens, grossPremiumLast, premiumOwed, premiumAccumulators)`* : Querys the amount of premium available for withdrawal given a certain `premiumOwed` for a chunk. Returns the amount of premium available for withdrawal.

* *`_getTotalLiquidity(tokenId, leg)`* : Querys the total amount of liquidity sold in the corresponding chunk for a position leg. Returns the total amount of liquidity sold in a specific leg of an option position `(tokenId)`. This total liquidity is calculated as the sum of removed liquidity and net liquidity in the pool.
        
* *`_updateSettlementPostBurn(owner, tokenId, collectedByLeg, positionSize, commitLongSettled)`* : It Updates the settled tokens and grossPremiumLast for a chunk after a burn and Returns `realizedPremia` which is the amount of premium owed to the user for the burned position. and `premiaByLeg`  which is an array containing the amount of premia owed to the user for each leg of the burned position.
           
## 3. CollateralTracker.sol

The CollateralTracker contract is an ERC4626 Vault that plays a crucial role in managing and tracking liquidity and collateral within the Panoptic protocol. This contract serves several important functions:

* ***Liquidity Management***: It manages the token liquidity from passive Panoptic Liquidity Providers (PLPs) and the collateral associated with option positions.

* ***Payments and Distributions***: It handles the payment of commission fees and option premiums, manages intrinsic value payments for options, and facilitates the distribution of profits and losses (P&L).

* ***Calculations and Cost Determination***: The contract calculates liquidation bonuses and determines costs for forcefully exercising other users' options.

* ***Collateral Requirements***: The primary functionality of the CollateralTracker is to calculate and maintain the collateral requirements for every account and position in Panoptic. It updates collateral balances with each position minting or burning and ensures that accounts remain solvent.

* ***Risk Management***: By tracking and updating collateral balances, the contract helps maintain the solvency of the protocol and allows for the liquidation of distressed positions when necessary.

This contract is therefore considered vital for the safe and efficient operation of the Panoptic protocol, ensuring that liquidity and collateral are properly managed and that the protocol's solvency is maintained.



***Here is a breakdown of the key functions***:


* *`startToken(underlyingIsToken0, token0, token1, fee, panopticPool)`* : It Initializes a new collateral tracker for a specific token corresponding to the Panoptic Pool being created by the factory that called it.


***Collateral Token Information***
        

* *`getPoolData()`* : Gets the Panoptic pool data.

* *`name()`* : It returns name of token composed of underlying token symbol and pool data.

* *`symbol()`* : Returns symbol as prefixed symbol of underlying token.

* *`decimals()`* : Returns decimals of underlying token please note that this returns 0 if not present


***Limited Transfer Functions***

* *`transfer(recipient, amount)`* : . It transfers a specified amount of tokens from the caller to a recipient. If all requirements are met it returmns true
  
* *`transferFrom(from, to, amount)`* :  It transfers a specified amount of tokens from from to to using the caller's allowance. However, it adds an additional requirement that from must not have any open option positions on the Panoptic pool. If condition is met it transfers token and returns true.

***ERC4626 Interface***

The contract also fully implements the ERC4626 interface, ensuring compliance with the standard for ERC4626 vaults. It includes all essential functions for vault operations, such as depositing, withdrawing, and transferring assets, as well as managing shares and providing accounting information. For instance, the deposit function allows users to deposit assets into the vault, receiving shares in return, while the mint function lets users mint a specific amount of shares by depositing the corresponding amount of assets. For comprehensive details on each function, including parameters and return values, please refer to the official [ERC4626 DOCS](https://eips.ethereum.org/EIPS/eip-4626) documentation on the Ethereum EIPs repository, which  allows for the implementation of a standard API for tokenized Vaults representing shares of a single underlying EIP-20 token. This standard is an extension on the EIP-20 token that provides basic functionality for depositing and withdrawing tokens and reading balances.


***Accounting Logic***

* *`exerciseCost(currentTick, oracleTick, positionId, positionBalance, longAmounts) `* : Used to get the cost of exercising an option. Used during a forced exercise. Returns the fees `(in LeftRightSigned)` for exercising an option position.

* *`_poolUtilization()`* : Get the pool utilization; it is a measure of the ratio of assets in the AMM vs the total assets managed by the pool and returns the pool utilization as a fraction.

* *`_sellCollateralRatio(utilization)`* : Get the (sell) collateral ratio that is paid when a short option is minted at a specific pool utilization. Returns the sell collateral ratio.

* *`_buyCollateralRatio(utilization)`* : Get the (buy) collateral ratio that is paid when a long option is minted at a specific pool utilization. Returns the buy collateral ratio.


***Life cycle of a collateral token and delegate/revoke logic***

* *`delegate(delegator, delegatee, assets)`* : Delegate and transfer shares corresponding to the incoming assets 'from' delegator 'to' delegatee. only called by the PanopticPool

* *`delegate(delegatee, assets)`* : Delegate and transfer shares corresponding to the incoming assets from the protocol to `delegatee`. Only called by the PanopticPool

* *`refund(delegatee, assets)`* : Refunds delegated tokens back to the protocol. Only called by PanopticPool.

* *`revoke(delegator, delegatee, assets)`* : Revoke previously delegated shares. The opposite of 'delegate'. Only called by PanopticPool

* *`refund(refunder, refundee, assets)`* : Refunds delegated tokens to 'refunder' from 'refundee', similar to 'revoke'. Only called by PanopticPool.


***Option Exercise & Commission***

* *`takeCommissionAddData(optionOwner, longAmount, shortAmount, swappedAmount)`* : Used to take commission on option creation/opening. Only called by PanopticPool. Returns the utilization of the panoptic pool.

* *`exercise(optionOwner, longAmount, shortAmount, swappedAmount, realizedPremium)`* : Exercises an option and pay to the seller what is owed from the buyer. Only called by PanopticPool. called when a position is burned because it meay need to be exercised. Returns The amount of tokens paid when closing that position.

* *`_getExchangedAmount(longAmount, shortAmount, swappedAmount)`* : Gets the amount exchanged to mint an option. Returns The amount of funds to be exchanged for minting an option


***Health & Collateral Tracking***

* *`getAccountMarginDetails(user, currentTick, positionBalanceArray, premiumAllPositions)`* : Gets the collateral status or margin details of an account or a user. Returns nformation collected for the tokens about the health of the account.The collateral balance of the user is in the right slot and the threshold for margin call is in the left slot

* *`_getAccountMargin(user, atTick, positionBalanceArray, premiumAllPositions)`* : Gets the collateral status or margin details of an account or user. Returns information collected for the tokens about the health of the account. The collateral balance of the user is in the right slot and the threshold for margin call is in the left slot.

* *`_getTotalRequiredCollateral(atTick, positionBalanceArray)`* : Gets the total required amount of collateral tokens of a user/account across all active positions to stay above the margin requirement. Returns the amount of tokens required to stay above the margin threshold for all active positions of user.

* *`_getRequiredCollateralAtTickSinglePosition(tokenId, positionSize, atTick, poolUtilization)`* : Gets the required amount of collateral tokens corresponding to a specific single position 'tokenId' at a price 'tick'. The required collateral of an account depends on the price ('tick') in the AMM pool: if in the position's favor less collateral needed. Returns the total required tokens for all legs of the specified tokenId.

* *`_getRequiredCollateralSingleLeg(tokenId, index, positionSize, atTick, poolUtilization) `* : Calculates the required amount of collateral for a single leg 'index' of position 'tokenId' when the leg does not have a risk partner. Returns the required amount collateral needed for this leg 'index'.

* *`_getRequiredCollateralSingleLegNoPartner(tokenId, index, positionSize, atTick, poolUtilization)`* : Calculate the required amount of collateral for leg 'index' of position 'tokenId' when the leg does not have a risk partner. Return The required amount collateral needed for this leg 'index'.

* *`_getRequiredCollateralSingleLegPartner(tokenId, index, positionSize, atTick,  poolUtilization)`* : Calculates the required amount of collateral for leg 'index' for position 'tokenId' accounting for its partner leg. Returns the required amount collateral needed for this leg 'index', accounting for what the leg's risk partner is.

* *`_getRequiredCollateralAtUtilization(amount, isLong, utilization)`* : Gets the base collateral requirement for an 'amount' at the current Panoptic pool 'utilization' level. Returns the required collateral corresponding to the incoming 'amount'.

*  *`_computeSpread(tokenId, positionSize, index, partnerIndex, poolUtilization)`* : Calculates the required amount of collateral for the spread portion of the spread position. Returns the required amount of collateral needed for the spread portion. 

*  *`_computeStrangle(tokenId, index, positionSize, atTick, poolUtilization)`* : Calculates the required amount of collateral for a strangle leg. Returns the required amount of collateral needed for the strangle leg.
 



## 4. PanopticFactory.sol

The Panoptic Factory is a smart contract designed to create and register Panoptic Pools, which deploy an options market on top of an existing Uniswap v3 pool. By leveraging the existing Uniswap liquidity infrastructure, the factory allows the creation of sophisticated financial products such as options on liquidity positions. The Panoptic Factory manages the deployment of these Panoptic Pools, ensuring that they are correctly initialized and registered within the protocol. This contract serves as the entry point for deploying Panoptic Pools, enabling users to create and access advanced derivatives markets seamlessly.

        
***Here is a breakdown of the key functions***:

* *`initialize(address _owner)`* : Used to initiallize the state. Basically the first owner of the PanopticFactory.


***Access Controll***

* *`transferOwnership(address newOwner)`* : Used to set the new owner of the PanopticFactory.

* *`owner()`* : Gets the address of the owner of this Panoptic Factory.


***Callback Handlers***

* *`uniswapV3MintCallback(amount0Owed, amount1Owed, data`* : Called after minting liquidity to a position.


***Pool Deployment***

* *`deployNewPool(token0, token1, fee, salt)`* : Creates a new Panoptic Pool linked to the given Uniswap pool identified uniquely by the incoming parameters. Returns the address of the newly deployed Panoptic pool


***Helpers***

* *`minePoolAddress(salt, loops, minTargetRarity)`* : Finds the salt which would give a Panoptic Pool the highest rarity within the search parameters. Returns the rarity of `bestSalt`

* *`_mintFullRange(v3Pool, token0, token1, fee)`* : Seeds Uniswap V3 pool with a full-tick-range liquidity deployment using funds from caller. Returns the amount of token0 and token1 deployed at full range.

***Queries***

* *`getPanopticPool(IUniswapV3Pool univ3pool)`* : Returns the address of the Panoptic Pool associated with 'univ3pool'
       
       
 * * ## LIBRARIES

## 1. CallbackLib.sol

The CallbackLib library serves as a utility for validating the legitimacy of callbacks from Uniswap V3 pools. It includes functions to verify that a callback originates from a canonical Uniswap V3 pool with a specified set of features, such as token pairs and fee structure.

The core functionality of the library is encapsulated in the validateCallback function. This function uses the Uniswap V3 factory to verify that the sender of the callback matches the expected pool, confirming that the callback is coming from the correct source and contains the correct features.

By utilizing this library, developers can maintain the security and integrity of their applications when interacting with Uniswap V3 pools. This is important for ensuring that callbacks are legitimate and not tampered with, preventing potential exploits or attacks that could arise from handling unverified or unauthorized callbacks.

In summary, the CallbackLib library enhances the safety and reliability of applications that interact with Uniswap V3 by providing a structured approach to verifying callbacks and validating their origin against the canonical Uniswap V3 factory.

***Key Function***

* *`validateCallback(sender, factory, factory)`* : This function checks whether a callback originated from the canonical Uniswap V3 pool with the claimed set of features (token pair and fee). It verifies the sender's address by querying the Uniswap V3 factory to match the sender with the expected pool, and reverts the transaction if the verification fails.

## 2. Constants.sol

This contract defines a library of constants used in Panoptic. It includes fixed point multipliers for precision calculations and sets the minimum and maximum possible values for price ticks and square root prices in a Uniswap V3 pool. These constants help ensure accuracy and consistency in Panoptic's calculations and operations.

## 3. Errors.sol

This contract defines a library of custom error messages used in the Panoptic protocol. These error messages are specific to different scenarios and conditions that may arise during the operation of the protocol, such as casting errors, liquidity and collateral issues, invalid input parameters, and unauthorized actions. By using custom error messages, the library helps improve the readability and clarity of error handling in the code, providing meaningful explanations for issues that may occur during contract execution.

## 4. FeesCalc.sol

This contract defines a library for fee calculations in the Panoptic protocol. It provides functions to compute fees accumulated within option position legs, known as liquidity chunks, in the Uniswap V3 pool. It calculates the net asset value (NAV) of a user's option portfolio at a given tick and computes the accumulated AMM swap/trading fees within a liquidity chunk. The library uses functions to retrieve information from the Uniswap V3 pool and calculate fees for token0 and token1 based on different price tick ranges. This library aids in accurately calculating and managing fees within the protocol.
       
        
***Here is a breakdown of the key functions***:

* *`getPortfolioValue(atTick, userBalance, positionIdList)`* : This function calculates the net asset value (NAV) of a user's option portfolio at a specific price tick within a Uniswap V3 pool. It takes the user's balance and a list of their positions in the pool, then calculates the total value of token0 and token1 owned by the portfolio based on the user's positions and the current price tick. Returns the amount of token0 and token1 owned by the user's portfolio.


* *`calculateAMMSwapFees(univ3pool, currentTick, tickLower, tickUpper, liquidity)`* : It calculates the swap fees collected from a Uniswap V3 pool for a given liquidity chunk. It takes parameters such as the pool itself, the current price tick, the lower and upper ticks of the chunk, and the amount of liquidity. It then calculates the accumulated fees for each token (token0 and token1) based on the fees per unit of liquidity collected within the chunk. Returns a packed representation of the fees collected for each token, with token0 in the right slot and token1 in the left slot.

* *`_getAMMSwapFeesPerLiquidityCollected(univ3pool, currentTick, tickLower, tickUpper)`* : Calculates the fee growth that has occurred (per unit of liquidity) in the AMM/Uniswap for an option position's tick range. Returns the fee growth in the AMM of token0 and token1.


## 5. InteractionHelper.sol

The **InteractionHelper** library in the Panoptic protocol is designed to handle interactions with external contracts and manage token approvals, token names, symbols, and decimals. It provides utility functions that facilitate approvals for token transfers and manage metadata-related operations for token names and symbols. By delegating these tasks to a separate library, the core contract can optimize bytecode size and improve efficiency in its operations. The library serves as a supporting module for the Panoptic protocol, assisting with crucial tasks related to external interactions and metadata management.
             
       
***Here is a breakdown of the key functions***:


* *`doApprovals(sfpm, ct0, ct1, token0, token1)`* : It performs approvals on behalf of the PanopticPool for CollateralTracker and SemiFungiblePositionManager.

* *`computeName(token0, token1, isToken0, fee, prefix)`* : Computes the name of a CollateralTracker based on the token composition and fee of the underlying Uniswap Pool. Returns The complete name of the collateral token calling this function

* *`computeSymbol(token, prefix)`* : Returns symbol as prefixed symbol of underlying token.

* *`computeDecimals(token)`* : Returns decimals of underlying token (0 if not present).

## 6. Math.sol


This library Contains general math helpers and functions

***Here is a breakdown of the key functions***:

* *`min24( a,  b) `* : Computes the min of the incoming int24s `a` and `b`.

* *`max24(int24 a, int24 b)`* : Computes the max of the incoming int24s `a` and `b`.

* *`min(a,  b)`* :  Computes the min of the incoming `a` and `b`.

* *`max(a,  b)`* : Computes the max of the incoming `a` and `b`.
  
* *`abs(int256 x)`* : Compute the absolute value of an integer (int256).

* *`absUint(int256 x)`* : Compute the absolute value of an integer (int256).

* *`mostSignificantNibble(uint160 x)`* : Returns the index of the most significant nibble of the 160-bit number,

        
   ***Tick Math***

* *`getSqrtRatioAtTick(int24 tick) `* : It calculates the square root of the price ratio for a given tick value in the Uniswap V3 protocol. It uses Uniswap's constants and operates with binary representations of the tick value to compute the square root of the price ratio at the given tick, which is returned as a fixed-point number. If the tick value is negative, it calculates the inverse of the square root ratio. The function is implemented to handle different ticks and compute the square root ratio as required in the Uniswap V3 protocol.            
  
  ***Liquidity Amount***
* *`getAmount0ForLiquidity(iquidityChunk)`* : Calculates the amount of token0 received for a given LiquidityChunk. Returns token0.

* *`getAmount1ForLiquidity(liquidityChunk) `*: Calculates the amount of token0 received for a given LiquidityChunk. Returns token1.

* *`getAmountsForLiquidity(currentTick, liquidityChunk)`* : Calculates the amount of token0 and token1 received for a given LiquidityChunk at the provided currentTick. Returns the amount of token0 and token 1.

* *`getLiquidityForAmount0(tickLower, tickUpper) `* : Returns a LiquidityChunk with `liquidity` corresponding to `amount0` at the provided ticks.

* *`getLiquidityForAmount1(tickLower, tickUpper, amount1)`* :Returns a LiquidityChunk with `liquidity` corresponding to `amount1` at the provided ticks.


***Casting***

* *`toUint128(uint256 toDowncast)`* : Downcasts uint256 to uint128. Revert on overflow or underflow. Returns the downcasted uint

* *`toUint128Capped(uint256 toDowncast)`* : Downcasts uint256 to uint128, but cap at type(uint128).max on overflow. Return the downcasted uint.

* *`toInt128(uint128 toCast)`* : Recasts uint128 to int128.

* *`toInt128(int256 toCast)`* : Casts an int256 to an int128, revert on overflow or underflow.

* *`toInt256(uint256 toCast)`* : Cast a uint256 to an int256, revert on overflow.


***MulDiv Algorithms***

 * *`mulDiv(a, b, denominator)`* : performs a multiplication of two uint256 integers, a and b, and then divides the product by a denominator with full precision. It calculates the floor of the division and handles overflow and division by zero errors. Returns a 256-bit integer (uint256) that is the result of multiplying the two given integers (a and b), and then dividing the product by the given denominator. This result is calculated with full precision and rounded down (floor) to ensure the final value is an integer. 
 *  *`mulDivRoundingUp(a, b, denominator)`* : Calculates ceil with full precision. Throws if result overflows a uint256 or denominator == 0. Returns The 256-bit result
 *  *`mulDiv64(uint256 a, uint256 b)`* : Calculates floor with full precision. Throws if result overflows a uint256. Returns The 256-bit result. 

 *  *`mulDiv96(uint256 a, uint256 b)`*  : Calculates floor(a×b÷2^96) with full precision. Throws if result overflows a uint256. Returns The 256-bit result.

 *  *`mulDiv96RoundingUp(uint256 a, uint256 b)`* : Calculates ceil(a×b÷2^96) with full precision. Throws if result overflows a uint256. Returns The 256-bit result.

 *  *`mulDiv128(uint256 a, uint256 b)`* : Calculates floor(a×b÷2^128) with full precision. Throws if result overflows a uint256. returns the 256-bit result.
   
 * *` mulDiv128RoundingUp(uint256 a, uint256 b)`* : Calculates ceil(a×b÷2^128) with full precision. Throws if result overflows a uint256. Returns the 256-bit result.
  
 * *`mulDiv192(uint256 a, uint256 b)`* : Calculates floor(a×b÷2^192) with full precision. Throws if result overflows a uint256. Returns The 256-bit result.
  
 * *`unsafeDivRoundingUp(uint256 a, uint256 b)`* : Calculates ceil(a÷b), returning 0 if b == 0. Returns The 256-bit result. 


***Sorting***

* *`quickSort(arr, left, right)`* : QuickSort is a sorting algorithm that employs the Divide and Conquer strategy. It selects a pivot element and arranges the given array around this pivot by correctly positioning it within the sorted array.
  
* *`sort(data)`* : Calls `quickSort` with default starting index of 0 and ending index of the last element in the array.


## 7. PanopticMath.sol

This library Computes general math quantities relevant to Panoptic and AMM pool management.

***Here is a breakdown of the key functions***:

***Math Helpers***

* *`getPoolId(univ3pool)`* : calculates and returns a unique 64-bit identifier (uint64) for a given Uniswap v3 pool address. It combines the last 48 bits (most significant) of the pool address with the tickSpacing of the pool (in the highest 16 bits), creating a pool ID for use in Panoptic's TokenId.

* *`incrementPoolPattern(poolId)`*  : Increments the pool pattern (first 48 bits) of a poolId by 1. Returns the provided `poolId` with its pool pattern slot incremented by 1.

* *`numberOfLeadingHexZeros( addr)`* : calculates and returns the number of leading hex characters (zeros) in a given Ethereum address. It uses the most significant nibble of the address to determine the count of leading zero hex characters.


***Oracle Calculations***

* *`updatePositionsHash(existingHash, tokenId, addFlag)`* : Updates an existing account's "positions hash" with a new single position `tokenId`.

* *`computeMedianObservedPrice(univ3pool, observationIndex, observationCardinality, cardinality, period)`* : Returns the median of the last `cardinality` average prices over `period` observations from `univ3pool`. Returns the median of `cardinality` observations spaced by `period` in the Uniswap pool.

* *`computeInternalMedian(observationIndex, observationCardinality, period, medianData,  univ3pool)`* : Takes a packed structure representing a sorted 7-slot ring buffer of ticks and returns the median of those values.

* *`twapFilter(univ3pool, twapWindow)`* : Computes the twap of a Uniswap V3 pool using data from its oracle. Returns the final calculated TWAP tick.


***Liquidity Calculation***

* *`getLiquidityChunk(tokenId, legIndex, positionSize)`* : calculates the liquidity chunk for a given option position (tokenId), leg index (legIndex), and position size (positionSize). It computes the tick range and liquidity (ownership share) in the Uniswap v3 pool based on the option position's asset parameter and specified leg.

* *`getTicks(strike, width, tickSpacing)`* : Extracts the tick range specified by `strike` and `width` for the given `tickSpacing`, if valid. Retuns The lower and upper tick of the liquidity chunk.
* *`getRangesFromStrike(width, tickSpacing)`* : Returns the distances of the upper and lower ticks from the strike for a position with the given width and tickSpacing. Returns the lower and upper tick  of the range.


***Token Conversion Logic***

* *`computeExercisedAmounts(tokenId, positionSize)`* : Compute the amount of funds that are underlying this option position. This is useful when exercising a position. returns two packed words: `longAmounts` and `shortAmounts`. Each word contains the total contract size (right) and total notional (left) of long and short positions, respectively, for an option position (tokenId) and specified positionSize.

* *`convertCollateralData(tokenData0, tokenData1, tokenType, sqrtPriceX96)`* : Adds required collateral and collateral balance from collateralTracker0 and collateralTracker1 and converts to single values in terms of `tokenType`. Returns The total combined balance of token0 and token1 for a user in terms of tokenType
and the combined collateral requirement for a user in terms of tokenType.

* *`convertNotional(contractSize, tickLower, tickUpper,  asset)`* : Computes the notional amount given an incoming total number of `contracts` deployed between `tickLower` and `tickUpper`. Returns the notional value of the option position.

* *`convert0to1(amount, sqrtPriceX96)`* : Convert an amount of token0 into an amount of token1 given the sqrtPriceX96 in a Uniswap pool defined as sqrt(1/0)*2^96. Returns The converted `amount` of token0 represented in terms of token1.

* *`convert1to0(amount, sqrtPriceX96)`* : Convert an amount of token1 into an amount of token0 given the sqrtPriceX96 in a Uniswap pool defined as sqrt(1/0)*2^96. Returns the converted `amount` of token1 represented in terms of token0

* *`convert0to1(amount, sqrtPriceX96)`* : Converts an amount of token0 into an amount of token1 given the sqrtPriceX96 in a Uniswap pool defined as sqrt(1/0)*2^96. Returns the converted `amount` of token0 represented in terms of token1.

* *`convert1to0(amount, sqrtPriceX96)`* : Converts an amount of token0 into an amount of token1 given the sqrtPriceX96 in a Uniswap pool defined as sqrt(1/0)*2^96. Returns the converted `amount` of token0 represented in terms of token1.

* *`getAmountsMoved(tokenId, positionSize, legIndex) `* : Computes the amount of token0 and token1 moved. Given an option position `tokenId`, leg index `legIndex`, and how many contracts are in the leg `positionSize`. Returns a LeftRight encoded variable containing the amount0 and the amount1 value controlled by this option position's leg.

* *`_calculateIOAmounts(tokenId, positionSize, legIndex)`* : Computes the amount of funds that are moved to and removed from the Panoptic Pool. Returns two packed words: longs and shorts. Each contains the total amount of long and short positions, respectively, based on the provided option position (tokenId), position size, and leg index


***Revoke/Refund Computations***

* *`getLiquidationBonus(tokenData0, tokenData1, sqrtPriceX96Twap, sqrtPriceX96Final, netExchanged, premia) `* : Checks that the account is liquidatable, get the split of bonus0 and bonus1 amounts. returns three values: bonus0: The bonus amount for token0. bonus1: The bonus amount for token1. A packed word (LeftRightSigned) representing the protocol loss for both tokens (delta between the user's balance and expended tokens).

* *`haircutPremia(liquidatee, positionIdList, premiasByLeg, collateralRemaining, collateral0, collateral1, sqrtPriceX96Final)`* : Haircut/clawback any premium paid by `liquidatee` on `positionIdList` over the protocol loss threshold during a liquidation. Returns the delta in bonus0 and bonus1 for the liquidator post-haircut.

* *`getRefundAmounts(refunder, refundValues, atTick, collateral0, collateral1)`* : Returns the original delegated value to a user at a certain tick based on the available collateral from the exercised user.


## 8. SafeTransferLib.sol

This Library  facilitates safe transfers of ERC20 tokens. It provides functions to transfer tokens either from one address to another or directly to a specified address while ensuring the transfers are successful and handling any potential errors gracefully.
       
        
***Here is a breakdown of the key functions***:

* *`safeTransferFrom(token,  from,  to, amount)`* : Safely transfers ERC20 tokens from one address to another.

* *`safeTransfer(token, to, amount)`* : Safely transfers ERC20 tokens to a specified address.


  * * ## MULTICALL

## Multicall.sol

The Multicall contract is an abstract contract that allows for the execution of multiple function calls within a single transaction. This enables batch operations, which can be useful for managing multiple contract interactions in a single step, such as during an "emergency exit" or when creating complex positions. The contract accepts an array of call data as input and executes each call in sequence using delegatecall. If any call fails, it propagates the revert reason from the failed call, ensuring consistent error handling. Upon successful execution, it returns the data from each call as an array of byte strings.


* * ## TOKENS

## 1. ERC20Minimall.sol

The ERC20Minimal contract is an abstract implementation of an ERC20 token that provides essential token functionality without metadata. This contract allows for the creation and management of ERC20 tokens, including token transfers, approvals, and events for these operations. Key features include:

Events: It emits standard ERC20 events such as Transfer when tokens are transferred, and Approval when an account grants approval to another account to spend tokens on its behalf.

Storage: The contract maintains storage for the total supply of tokens, token balances for each account, and allowances for approved spenders.

Functionality: It provides methods to approve token spending by other accounts, transfer tokens between accounts, and transfer tokens using approvals (i.e., transferFrom). It includes internal utility functions for minting new tokens to an account and burning tokens from an account.

Internal Mint/Burn Logic: It provides internal functions for minting and burning tokens, which update balances and the total supply accordingly.

The contract serves as a base for more specific ERC20 token implementations, allowing inheriting contracts to define metadata and additional functionality as needed.


 ***Here is a breakdown of the key functions***:

 * *`transferFrom(from, to, amount)`* : Transfers tokens from one user to another.
  
 * *`_transferFrom from, to, amount)`* : Internal utility to transfer tokens from one user to another. 


***Internal Mint /Burn Logic**

* *`_mint(address to, uint256 amount)`* : Internal utility to mint tokens to a user's account.
  
* *`_burn(address from, uint256 amount)`* : Internal utility to burn tokens from a user's account.


    * * ## TOKENS/INTERFACES

## 1. IDonorNFT.sol

The IDonorNFT interface specifies the requirements for issuing a non-fungible token (NFT) as a reward to the deployer of a new PanopticPool through the PanopticFactory. The purpose of this interface is to outline the method (issueNFT) that must be implemented by a contract that intends to provide an NFT reward to the address (deployer) responsible for deploying a new PanopticPool and donating funds for full-range liquidity.

 ***Here is a breakdown of the key functions***:

The key function in this interface is issueNFT, which is called to issue an NFT to the deployer of a new PanopticPool.
The function takes several parameters including:
deployer: The address of the deployer who deployed the new pool and donated funds.
newPoolContract: The address of the newly deployed PanopticPool.
token0 and token1: Addresses of the two tokens in the Uniswap pool that the new pool was deployed on.
fee: The fee tier, specified in hundredths of basis points, of the Uniswap pool on which the new pool was deployed.
It is designed to provide an outline for a method to reward the deployer of a PanopticPool with an NFT as a token of appreciation for their contributions.

## 2. IERCPartial.sol


The IERC20Partial interface is a partial definition of the ERC20 token standard as defined in the Ethereum Improvement Proposal (EIP). This interface outlines key functions for ERC20 tokens but does not include return values for certain functions, as some tokens (e.g., USDT) may not fully comply with the ERC20 standard by not returning a value.

provides a minimal set of functions for interacting with ERC20 tokens, allowing for flexibility and compatibility with both compliant and non-compliant tokens.

 ***Here is a breakdown of the key functions***:

* balanceOf( account): Returns the balance of a given account (address).
* approve(spender,  amount): Sets an allowance for a spender to access the caller's tokens. Although the ERC20 standard specifies a return value, this interface does not expect one.

* transfer(to, amount): Transfers tokens from the caller's account to another specified account.

The interface is designed to work with both compliant and non-compliant tokens, and clients are advised to handle any potential issues, such as negative success values.

Overall, the IERC20Partial interface provides a streamlined and flexible way to interact with ERC20 tokens while taking into account variations in token implementations that may not fully adhere to the ERC20 standard.

  * * ## TYPES

## 1. LeftRight.sol

The IERC20Partial interface provides a partial implementation of the ERC20 token standard, focusing on essential methods for token interaction. It includes functions to check the balance of an account (balanceOf), approve a spender for a specific amount (approve), and transfer tokens to another account (transfer). This interface is designed to work with both compliant and non-compliant tokens, as it does not require return values for the approve and transfer functions. By allowing these methods to work seamlessly across different token implementations, the interface supports compatibility and flexibility for developers working with various ERC20 tokens.

 ***Here is a breakdown of the key functions***:

 * *`rightSlot(self)`* : Get the "right" slot from a bit pattern. Returns the returns the he right half of `self`

 * *`rightSlot(self)`* : Get the "right" slot from a bit pattern. Returns the returns the he right half of `self`
 
 * *`toRightSlot(self, right)`* : Adds to the "right" slot in a 256-bit pattern. Retuns `self` with `right` added (not overwritten, but added) to the value in its right 128 bits
  
 * *`toRightSlot(self, right)`* : Adds to the "right" slot in a 256-bit pattern. Retuns `self` with `right` added (not overwritten, but added) to the value in its right 128 bits
 
 ***Left Slot***
  
 * *` leftSlot( self)`* : Get the "left" slot from a bit pattern. returns the he left half of `self`
  
 * *` leftSlot( self)`* : Get the "left" slot from a bit pattern. returns the he left half of `self`
  
 * *`toLeftSlot(self,left) `* : All toLeftSlot functions add bits to the left slot without clearing it first Typically, the slot is already clear when writing to it, but if it is not, the bits will be added to the existing bits Therefore, the assumption must not be made that the bits will be cleared while using these helpers. Returns `self` with `left` added (not overwritten, but added) to the value in its left 128 bits.

 * *`toLeftSlot(LeftRightSigned self, int128 left)`* : Add to the "left" slot in a 256-bit pattern. Returns `self` with `left` added (not overwritten, but added) to the value in its left 128 bits.

***Math Helpers***

* *`add(x, y)`* : Add two LeftRight-encoded words; revert on overflow or underflow. Returns z sum of x + y.

* *`sub(x, y)`* : Subtract two LeftRight-encoded words; revert on overflow or underflow. Returns z difference of x - y

* *`add(x, y)`* : Add two LeftRight-encoded words; revert on overflow or underflow. Returns z sum of x + y.
  
* *`add(x, y)`* : Add two LeftRight-encoded words; revert on overflow or underflow. Returns z sum of x + y.

* *`sub(x, y)`* : Subtract two LeftRight-encoded words; revert on overflow or underflow. Returns z difference of x - y

* *`subRect(x, y)`* : Subtract two LeftRight-encoded words; revert on overflow or underflow. Returns z difference of x - y.
* *`addCapped(x, dx, y, dy)`* : Adds two sets of LeftRight-encoded words, freezing both right slots if either overflows, and vice versa. Returns  sum of x + dx and y : dy.


## 2. LiquidityChunck.sol

The LiquidityChunkLibrary contract provides utility functions for managing and interacting with liquidity chunks in a concentrated liquidity AMM (automated market maker). A liquidity chunk represents an amount of liquidity deployed between two price ticks (tickLower and tickUpper). This library allows encoding and decoding of liquidity chunk information packed into a uint256 type. Functions in the library include creating a new liquidity chunk, adding liquidity, updating tick values, and retrieving the lower tick, upper tick, and liquidity of a chunk. These operations are essential for managing the liquidity and tick ranges of an option position identified by TokenId.sol in the Panoptic protocol.

 ***Here is a breakdown of the key functions***:

 * *`createChunk(_tickLower, _tickUpper, amount)`* : Creates a new `LiquidityChunk` given by its bounding ticks and its liquidity. Returns the new chunk with the given liquidity and tick range.
  
 * *`addLiquidity(self, amount)`* : Add liquidity to `self`. Returns `self` with added liquidity `amount`.
  
 * *`addTickLower(self, _tickLower)`* : Add the lower tick to `self`. Returns `self` with added lower tick `_tickLower`.
  
 * *`addTickUpper(self, _tickUpper)`* : Add the upper tick to `self`. Returns `self` with added upper tick `_tickUpper`.
  
 * *`updateTickLower(self, _tickLower)`* : Overwrites the lower tick on `self`. Returns `self` with `_tickLower` as the new lower tick
  
 * *`updateTickUpper(self, _tickUpper)`* : Overwrites the upper tick on `self`. Returns `self` with `_tickUpper` as the new upper tick
 

 ***Decoding***

 * *`tickLower(LiquidityChunk self)`* : Get the lower tick of `self`. Return The lower tick of `self`.
 * *`tickUpper(LiquidityChunk self)`* : Get the upper tick of `self`.. Return The upper tick of `self`.
 * *`liquidity(LiquidityChunk self)`* : Get the amount of liquidity/size of `self`. Return The liquidity of `self`.

## 3. TokenId.sol

This is the token ID used in the ERC1155 representation of the option position in the SFPM. The SFPM "overloads" the ERC1155 `id` by storing all option information in said `id`. it Contains methods for packing and unpacking a Panoptic options position into a uint256 bit pattern.

* *`poolId(self)`* : The full poolId (Uniswap pool identifier + pool pattern) of this option position. Returns The `poolId` (Panoptic's pool fingerprint, contains the whole 64 bit sequence with the tickSpacing) of the Uniswap V3 pool

* *`tickSpacing(TokenId self)`* : The tickSpacing of this option position. Returns The `tickSpacing` of the Uniswap v3 pool

* *`asset(self,  legIndex)`* : Get the asset basis for this TokenId. Returns 0 if asset is token0, 1 if asset is token1

* *`optionRatio(self,  legIndex)`* : Get the number of contracts multiplier for leg `legIndex`. Returns The number of contracts multiplier for leg `legIndex`
* *`isLong(self, legIndex)`* : Return 1 if the nth leg (leg index `legIndex`) is a long position. Returns 1 if long; 0 if not long
  
* *`tokenType(self, legIndex)`* : Get the type of token moved for a given leg (implies a call or put). Either Token0 or Token1. returns 1 if the token moved is token1 or 0 if the token moved is token0.

* *`riskPartner( self, legIndex)`* : Get the associated risk partner of the leg index (generally another leg index in the position if enabled or the same leg index if no partner). Returns The leg index of `legIndex`'s risk partner

* *`strike(self, legIndex)`* : Get the strike price tick of the nth leg (with index `legIndex`). Returns The strike price (the underlying price of the leg)
  
* *`width(self, legIndex)`* : Get the width of the nth leg (index `legIndex`). This is half the tick-range covered by the leg (tickUpper - tickLower)/2. Returns The width of the position
       

    ***Encoding***

* *`addPoolId(self, _poolId) `* :Add the Uniswap V3 Pool pointed to by this option position (contains the entropy and tickSpacing). Return `self` with `_poolId` added to the PoolID slot

* *`addTickSpacing(TokenId self, int24 _tickSpacing)`* : Add the `tickSpacing` to the PoolID for `self`. Returns `self` with `_tickSpacing` added to the TickSpacing slot in the PoolID.

* *`addAsset(self, _asset, legIndex)`* : Add the asset basis for this position. Returns `self` with `_asset` added to the Asset slot

* *`addOptionRatio(self, _optionRatio, legIndex)`* : Add the number of contracts multiplier to leg index `legIndex`. Returns `self` with `_optionRatio` added to the OptionRatio slot for `legIndex`

* *`addIsLong(self, _isLong, legIndex)`* : Add "isLong" parameter indicating whether a leg is long (isLong=1) or short (isLong=0). Returns `self` with `_isLong` added to the IsLong slot for `legIndex`
* *`addTokenType(self, _tokenType, legIndex)`* : Add the type of token moved for a given leg (implies a call or put). Either Token0 or Token1. Returns `self` with `_tokenType` added to the TokenType slot for `legIndex`.

* *`addRiskPartner(self, _riskPartner, legIndex)`* : Add the associated risk partner of the leg index (generally another leg in the overall position). Return `self` with `_riskPartner` added to the RiskPartner slot for `legIndex`.

* *`addStrike(self, _strike, legIndex)`* : Add the strike price tick of the nth leg (index `legIndex`). Returns `self` with `_strike` added to the Strike slot for `legIndex`

* *`addWidth(self, _width, legIndex)`* : Add the width of the nth leg (index `legIndex`). Returns `self` with `_width` added to the Width slot for `legIndex`.

* *`addLeg(self, legIndex, _optionRatio, _asset, _isLong, _tokenType,  _riskPartner, _strike, _width)`* : Add a leg to a TokenId. Returns tokenId The tokenId with the leg added.

***Helpers***

* *`flipToBurnToken(TokenId self)`* : Flip all the `isLong` positions in the legs in the `tokenId` option position. Returns the tokenId with all `isLong` bits flipped

* *`countLongs(TokenId self)`* : Get the number of longs in this option position. Returns Get the number of longs in this option position.

* *`asTicks(self, legIndex)`* : Get the option position's nth leg's (index `legIndex`) tick ranges (lower, upper). Returns legUpperTick The lower upper tick of the leg/liquidity chunk.

* *`countLegs(TokenId self)`* : Return the number of active legs in the option position. Returns The number of active legs in `self` (in the range {0,...,4}).

* *`clearLeg(self, i)`* : Clear a leg in an option position with index `i`. Returns `self` with the `i`th leg zeroed including optionRatio and asset
        

   ***validation***
* *`validate(TokenId self)`* : Validate an option position and all its active legs; return the underlying AMM address.

* *`validateIsExercisable(self, currentTick)`* : Validate that a position `self` and its legs/chunks are exercisable.



## Key Protocol Invariants

* Users of the SFPM can only remove liquidity (via isLong==1 or burning positions) that they have previously added under the same (tickLower, tickUpper, tokenType) key. They cannot remove liquidity owned by other users.

* Fees collected from Uniswap during any given operation should not exceed the amount of fees earned by the liquidity owned by the user performing the operation.

* Fees paid to a given user should not exceed the amount of fees earned by the liquidity owned by that user.
Panoptic:


* Commission paid by an account should be greater than or equal to 1 (of either) token

* Option sellers must pay back the exact amounts of tokens that were borrowed (the "shortAmounts") when their positions are burned

* Option buyers must add back the same amount of liquidity that was borrowed when their positions are burned

* Users should not be allowed to mint/burn options or pay premium if their end state is insolvent (at the fast oracle tick, or both ticks if the fast and slow oracle ticks are further away than the threshold)
* Users should not be allowed to withdraw collateral if they have open positions
  
* Users should not be allowed to mint more positions than the limit
  
* Option sellers should not receive premium that has not settled (by collection from Uniswap or payments from long option holders) yet
  
* Option sellers in a given chunk should not receive premium, as a fraction of the premium owed to them , that is greater than the ratio of total owed premium to total settled premium in that chunk

* Liquidations must only occur if the liquidated account is insolvent at the TWAP tick and the TWAP tick is not above the threshold for distance to the current tick
  
* Note that some executable liquidations may not be profitable due to the required actions to execute the liquidation (depositing collateral, force exercises) or the price the token conversions occur at

* Note that it is acceptable for an account to cause protocol loss (shares minted to liquidator) during a liquidation even if they have a residual token balance in their account, this may happen if the value of tokens remaining correspond to less than 1 of the other token

* If, at the final state after a liquidation, any premium paid to sellers DURING the liquidation has not been revoked, there must not be any protocol loss (shares minted to liquidator). In other words, this means that premium cannot be paid over the protocol loss threshold.

* The value of the bonus paid to the liquidator must not exceed the liquidated user's collateral balance at the beginning of the call.


## Approach taken in evaluating Panoptic Protocol

**I analyzed and audited the Protocol in the following steps:**

## 1. Reviewing the Protocol Contracts

My approach involved a meticulous examination of the codebase and the interdependencies among the key contracts within the Panoptic ecosystem. The objective was to gain a comprehensive understanding of the system's architecture and offer strategic recommendations to enhance its performance and effectiveness. By closely evaluating the critical contracts and their interactions, I aimed to identify areas for improvement and optimization in order to strengthen the overall functionality of the protocol.

During the review process, I conducted an in-depth examination of the Panoptic protocol's codebase, assessing the functionality, efficiency, and security of key contracts, interfaces, and libraries. The goal was to ensure that the system adheres to protocol invariants and operates seamlessly within the designed parameters.

I began by analyzing the contracts and libraries related to liquidity management, including the Liquidity Chunk Library, to verify their proper implementation and performance. This involved a thorough review of the encoding and decoding processes, as well as the handling of liquidity within specified tick ranges.

Next, I evaluated ERC20 interfaces and the usage of the Safe Transfer Library to ensure secure and efficient token transfers and operations. This included checking the library's compatibility with both compliant and non-compliant tokens and assessing the handling of missing return values.

I also examined the implementation and use of other core interfaces, such as IDonorNFT, to verify that they function as intended and support the protocol's objectives.

Throughout the review, I paid close attention to the protocol's fee structure, ensuring that the collection and distribution of fees align with the protocol's intended behavior and user expectations. I assessed whether fees collected during operations were appropriately attributed to the correct liquidity owners.

Furthermore, I evaluated the Panoptic protocol's handling of positions, option minting and burning, and liquidation processes. This included verifying that users could only interact with positions and liquidity they owned and ensuring that the protocol maintained solvency and adhered to liquidation rules.

Overall, my review aimed to identify any potential risks, vulnerabilities, or areas for optimization within the codebase. By thoroughly examining each aspect of the Panoptic protocol, I provided recommendations to enhance its performance, reliability, and security, contributing to the ongoing development and improvement of the system.

## 2. Documentation Review

 I also examined the protocol's documentation for a comprehensive understanding of its intended functionality and design principles. This provided further insight into the protocol's goals and helped verify that the implementation aligns with the specified requirements and behavior outlined in the documentation. The documentation can be found [here](https://panoptic.xyz/docs/intro).

## 3. Compiling code and running provided tests

## 4. Manual code review

I then conducted a detailed manual review of the code by going through each line, examining the logic and structure for potential improvements or issues. This involved comparing the implementation against the protocol's specifications and expected behavior. By assessing each contract and its functions line by line, I checked for any inconsistencies, inefficiencies, or security vulnerabilities. This meticulous approach ensured that the code adhered to best practices and met the requirements outlined in the protocol's documentation.

## Codebase Quality

Overall, the quality of the codebase for this protocol appears to be solid. The contracts demonstrate careful consideration in terms of architecture, error handling, and maintainability. Below are some key observations on the codebase quality:

Architecture & Design: The protocol is built on a modular architecture, with each contract and library having a specific, well-defined role within the system. This modularity promotes ease of maintenance and enhances the overall readability of the code. The utilization of libraries for specific operations, such as mathematical computations, optimizes performance and gas efficiency.

Upgradeability & Flexibility: While the protocol does not currently incorporate explicit upgradeability patterns such as proxy contracts, considering these design patterns could provide greater flexibility for future updates and enhancements. Implementing upgradeability strategies would allow for adaptations as the project evolves and the ecosystem's needs change.

Error Handling & Input Validation: Functions include input validation and error handling, which is crucial for ensuring that operations are carried out as intended and invalid transactions are prevented. A deeper examination of validation processes, particularly for edge cases, is recommended to ensure robustness.

Code Maintainability and Reliability: The codebase exhibits good maintainability and reliability, with each contract serving a distinct purpose and adhering to established best practices and patterns.

Code Comments: The code is generally well-documented with comments that explain the purpose and functionality of each section. However, areas involving complex mechanics or tokenomics could benefit from additional commentary to provide greater clarity and ease of understanding for developers and auditors.

Testing: The protocol demonstrates strong test coverage, ensuring that a wide range of functionalities and scenarios are thoroughly tested. Incorporating additional testing methodologies such as fuzz testing and invariant testing could further enhance the robustness and reliability of the codebase by simulating extreme conditions and verifying contract invariants.

Code Structure and Formatting: The codebase follows a consistent structure and formatting, adhering to Solidity programming conventions. This uniformity supports code readability and navigation. Breaking down more complex contracts into smaller, focused components could improve the codebase's modularity and facilitate easier updates and maintenance.

Strengths: The protocol showcases strong adherence to best practices in terms of security and standard compliance, emphasizing the importance of code safety and interoperability. The creative use of specific libraries for different functionalities demonstrates a thoughtful approach to contract design.

Documentation: The contracts include inline comments and brief descriptions of functionality beneficial for developers, auditors, and the community. Accurate and comprehensive documentation which ensures that users have a clear understanding of the protocol's architecture and functionalities, which is crucial for long-term success.
        

## Architecture

## System Workflow

The Panoptic protocol is a decentralized finance (DeFi) platform designed to facilitate options trading and liquidity provisioning. Here's the system workflow starting from when a user begins to interact with the protocol:

**User Interaction with Panoptic**: A user initiates an interaction with the Panoptic protocol through a variety of operations, such as providing liquidity, buying options, selling options, or burning positions.

**Providing Liquidity**: When a user decides to provide liquidity, they must specify the amount and type of tokens (e.g., WETH) they wish to supply. The protocol may also require the user to define a specific tick range (e.g., tickLower and tickUpper) within which the liquidity will be deployed.

**Liquidity Added to Uniswap**: The user's liquidity is then added to Uniswap within the specified tick range. This allows the user to earn fees from trades occurring in that range.

**Options Trading**: Users can participate in options trading by buying or selling options. Options are a type of financial derivative that provide the right, but not the obligation, to buy or sell an asset at a predetermined price (the strike price).

**Buying Options**: If a user buys an option, they pay a premium for the right to exercise the option in the future. This premium is paid to the seller (liquidity provider).

**Selling Options**: Users can also sell options, which involves providing liquidity for the options market. In return, they receive a premium from the option buyer.

**Premium Collection and Settlement**: As trades occur, the protocol collects and settles premiums. Premiums may be distributed to liquidity providers as a reward for facilitating trades.

**Burning Positions**: Users can burn positions to remove liquidity from the protocol. This involves specifying the positions they want to remove, and the protocol handles the necessary operations to withdraw the user's liquidity.

**Fee Distribution**: The protocol ensures that fees collected from Uniswap do not exceed the fees earned by the user's own liquidity. Fees paid to a user are proportional to the user's share of liquidity.

**Option Expiration and Settlement**: When options expire, they are settled according to their outcome. Depending on whether the option buyer decides to exercise the option, positions may be adjusted accordingly.

**Liquidation**: If a user is insolvent or unable to maintain their positions due to margin calls, the protocol may trigger a liquidation process. During liquidation, a liquidator may take over the user's positions to settle debts.

**Collateral Management**: Users must manage their collateral to ensure they remain solvent and can meet margin requirements for open positions. The protocol enforces these requirements to maintain system stability.

The Panoptic protocol combines these components to provide a comprehensive and flexible trading platform for digital assets. Users can trade assets, provide liquidity, and access accurate price information through the TWAP implementations.

| File name              | code Functionality | Technical Characteristics |Importance and Management |
| :----------------: | :------: |:----: | :----:  |
|   contracts/PanopticPool.sol    |   Create permissionless options on top of a concentrated liquidity AMM like Uniswap v3.   | Manages positions, collateral, liquidations and forced exercises. | The Panoptic Pool is essential as it serves as the primary interface for all user interactions with the Panoptic protocol, managing option positions, tracking user balances, and coordinating with the CollateralTracker to settle position changes, ensuring seamless and efficient operations.    |
| contracts/SemiFungiblePositionManager.sol           |   A gas-efficient alternative to Uniswap’s NonFungiblePositionManager that manages complex, multi-leg Uniswap positions encoded in ERC1155 tokenIds,   | performs swaps allowing users to mint positions with only one type of token, and, most crucially, supports the minting of both typical LP positions where liquidity is added to Uniswap and “long” positions where Uniswap liquidity is burnt.  |    It allows users to mint positions with one token type and supports both liquidity provision and “long” positions. As a core component of Panoptic, SFPM is designed to help Uniswap V3 LPs efficiently manage their liquidity.    |
| contracts/CollateralTracker.sol    |  An ERC4626 vault where token liquidity from passive Panoptic Liquidity Providers (PLPs) and collateral for option positions are deposited.   | responsible for paying out commission fees and options premia, handling payments of intrinsic value for options and distributing P&L, calculating liquidation bonuses, and determining costs for forcefully exercising another user’s options. |   calculate the collateral requirement for every account and position.     |
| contracts/PanopticFactory.sol |  All interactions with the protocol, be it minting or burning positions, liquidating or force exercising distressed accounts, or just checking position balances and accumulating premiums,    |  It is responsible for orchestrating the required calls to the SFPM to actually create option positions in Uniswap, |  tracking user balances of and accumulating the premia on those positions, and calling the CollateralTracker with the data it needs to settle position changes.     |


* * ## Repository structure and contracts I  looked at


| File      | Description |
| ----------- | ----------- |
| contracts/CollateralTracker      | ERC4626 vault where token liquidity from Panoptic Liquidity Providers (PLPs) and collateral for option positions are deposited and collateral requirements are computed"       |
| contracts/PanopticFactory   | Handles deployment of new Panoptic instances on top of Uniswap pools, initial liquidity deployments, and NFT rewards for deployers        |
| contracts/PanopticPool   | Coordinates all options trading activity - minting, burning, force exercises, liquidations        |
| contracts/SemiFungiblePositionManager   | The 'engine' of Panoptic - manages all Uniswap V3 positions in the protocol as well as being a more advanced, gas-efficient alternative to NFPM for Uniswap LPs        |
| tokens/ERC1155Minimal   | A minimalist implementation of the ERC1155 token standard without metadata        |
| tokens/ERC20Minimal   | A minimalist implementation of the ERC20 token standard without metadata        |
| tokens/interfaces/IDonorNFT   | An interface the PanopticFactory can use to issue reward NFTs        |
| tokens/interfaces/IERC20Partial   | An incomplete ERC20 interface containing functions used in Panoptic with some return values omitted to support noncompliant tokens such as USDT        |
| types/LeftRight   | Implementation for a set of custom data types that can hold two 128-bit numbers        |
| types/LiquidityChunk   | Implementation for a custom data type that can represent a liquidity chunk of a given size in Uniswap - containing a tickLower, tickUpper, and liquidity        |
| types/TokenId   | Implementation for the custom data type used in the SFPM and Panoptic to encode position data in 256-bit ERC1155 tokenIds - holds a pool identifier and up to four full position legs        |
| libraries/CallbackLib   | Library for verifying and decoding Uniswap callbacks        |
| libraries/Constants   | Library of Constants used in Panoptic        |
| libraries/Errors   | Contains all custom errors used in Panoptic's core contracts        |
| libraries/FeesCalc   | Utility to calculate up-to-date swap fees for liquidity chunks        |
| libraries/InteractionHelper   | Helpers to perform bytecode-size-heavy interactions with external contracts like batch approvals and metadata queries        |
| libraries/Math   | Library of generic math functions like abs(), mulDiv, etc        |
| libraries/PanopticMath   | Library containing advanced Panoptic/Uniswap-specific functionality such as our TWAP, price conversions, and position sizing math        |
| libraries/SafeTransferLib   | Safe ERC20 transfer library that gracefully handles missing return values        |
| multicall/multicall   | Adds a function to inheriting contracts that allows for multiple calls to be executed in a single transaction        |
        

 ## Systematic Risks

 Systemic risks in Panoptic primarily revolve around the dependencies on external protocols and services The protocol’s reliance on external ERC4626  vaults introduces potential systemic vulnerabilities, including smart contract failures or manipulations in the integrated protocols.


 ## Centralization Risks
Centralization risks stem from the roles and permissions granted to certain addresses within the protocol. For instance, the ability of the admin or owner to modify functions as below in CollateralTracker.s


* *`delegate(delegator, delegatee, assets)`* : Delegate and transfer shares corresponding to the incoming assets 'from' delegator 'to' delegatee. only called by the PanopticPool

* *`delegate(delegatee, assets)`* : Delegate and transfer shares corresponding to the incoming assets from the protocol to `delegatee`. Only called by the PanopticPool

* *`refund(delegatee, assets)`* : Refunds delegated tokens back to the protocol. Only called by PanopticPool.

* *`revoke(delegator, delegatee, assets)`* : Revoke previously delegated shares. The opposite of 'delegate'. Only called by PanopticPool

* *`refund(refunder, refundee, assets)`* : Refunds delegated tokens to 'refunder' from 'refundee', similar to 'revoke'. Only called by PanopticPool.

## Technical Risks
Smart Contract Vulnerabilities: Bugs or logical errors in the smart contracts can lead to loss of funds, unauthorized access, or unintended behavior. Given the complexity of contracts like the CollateralTracker, PanopticPool, and SemiFungiblePositionManager, the attack surface is significant.

Scalability Concerns: As transaction volumes grow, the platform must scale without compromising performance or security.

## Integration Risks

Integration risks for the Panoptic protocol primarily stem from its dependencies on external DeFi platforms, such as Uniswap, for liquidity management and trading services. The security and functionality of Panoptic depend on the stability and reliability of these external protocols. Any disruptions, including smart contract upgrades, API changes, or liquidity issues, could negatively impact Panoptic's operations.

Additionally, as the DeFi ecosystem evolves, Panoptic may face compatibility challenges with changes in the integrated protocols. Updates in these platforms could require corresponding adjustments in Panoptic's contracts to maintain security and efficiency. Continuous monitoring and proactive adaptation are necessary to mitigate potential integration risks and ensure seamless functionality.


## Codebase Quality


The quality of the Panoptic protocol codebase is commendable, reflecting mature software engineering practices with a focus on security, modularity, and clear documentation. The smart contracts adhere to established standards, aligning with best practices within the Ethereum development community. Key aspects of the codebase quality are outlined below:

|  Category      | Comments |
| ----------- | ----------- |
| Standards Compliance      | Panoptic utilizes ERC standards such as ERC-1155 and ERC-20, facilitating interoperability and integration within the broader DeFi ecosystem.       |
| Modularity and Reusability   | The codebase is designed with modularity in mind, promoting code reusability and easier updates or integrations with other protocols.        |
| Readability and Documentation   | Thorough comments and NatSpec documentation enhance the readability and comprehension of the code, aiding both new and experienced developers.        |
| Test Coverage and Security   | High test coverage, approaching 100%, ensures comprehensive testing of all code paths and scenarios, contributing to the protocol's reliability and security.        |
| Upgradeability and Maintenance   | The code structure supports future upgrades and maintenance, incorporating flexible and scalable patterns for long-term sustainability.        |
| Error Handling and Data Validation   | The code includes robust error handling with custom errors and input validation, providing clear feedback and assisting in issue identification.        |
| Resource Efficiency   | The code demonstrates efficient use of gas through careful structuring and optimization, focusing on reducing costs and maximizing performance.        |
| Consistency and Coding Conventions   | Adherence to common Solidity conventions and consistent naming standards contribute to a coherent and predictable code structure.        |
| Security Measures and Auditing   | Panoptic's contracts are designed with security as a priority, utilizing proven patterns and techniques. Ongoing audits would further validate the protocol's security.        |
        
        
        
## New Insights and Learning of Project from this Audit

During the audit of the Panoptic protocol, several key insights and learning opportunities emerged, highlighting the project's unique approach to decentralized finance and its integration within the Ethereum ecosystem. The audit offered an in-depth examination of the protocol's core mechanics, such as options trading within Uniswap liquidity pools, complex smart contract interactions, and security practices. Below are some of the primary insights and learnings derived from this audit:

Panoptic Options Trading Mechanics:
The concept of facilitating options trading within Uniswap liquidity pools is both innovative and sophisticated. Understanding how Panoptic manages the minting and burning of positions, as well as the intricate process of liquidating or exercising distressed accounts, required a detailed analysis of the various smart contracts and their interactions with Uniswap.

ERC-1155 Token Standard:
Panoptic’s use of the ERC-1155 token standard for managing multi-leg Uniswap positions provides flexibility and efficiency in tracking positions and managing liquidity. The audit offered a deeper understanding of the ERC-1155 standard and its benefits for Panoptic's unique use case.

Security Implications of Uniswap Integration:
The protocol’s reliance on Uniswap for liquidity and options trading introduces various security considerations. The audit emphasized the importance of evaluating the security and reliability of the interactions with Uniswap, including mechanisms for mitigating risks such as price manipulation and slippage.

Efficient Gas Usage and Optimization:
Analyzing the codebase for gas efficiency provided valuable insights into the mechanisms Panoptic uses to minimize transaction costs and optimize performance. The audit examined the use of efficient data structures, loop structures, and other optimization techniques.       
            
        
        
       
        
        
        


        
  


        

       
        


        
        
       




        
       
       
     
      
        
     
 
        
        
        
        
        
        

       
        
        
        

        


        
       

        



### Time spent:
90 hours